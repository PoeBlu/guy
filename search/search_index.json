{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Guy Guy is a way to make a simple GUI for your python script, using html/js/css technologies (a lit bit like electron ). It borrows the idea from python-eel , but provide a lot more things. The main idea, is to reuse the installed chrome app on the host. So your script (or your freezed app) stays at the minimal footprint. But your user needs to have Chrome (or chromium) on its computer, to run your script/app. If you want to release a standalone/freezed app, with all included (your script + a chrome container). You can include special mode with cefpython3 . But the footprint will be around 60mo (like an electron app). But you can ;-) There are 3 modes to release your app : app : your user will need to have a chrome instance. The GUI will be handled by a chrome instance, runned in \"app mode\". (on android/ios, the GUI will be handled by webViewClient/kivy) cef : (stands for cefpython3): All is embedded, it's the embedded cef instance which will handle your GUI. server : it will act as an http server, and any browsers can handle your GUI. So, there can be multiple clients ! Like you understand, your GUI should be built with HTML/JS/CSS. Under the hood, guy provides a simple mechanisms (with websockets) to interact with the python technologies. Your GUI can be native HTML/JS or any modern js frameworks : vuejs, angular, etc ... The app mode can be runned on an Android device, using kivy/buildozer toolchain (for building an apk). Understand that the same app can be runned on any android devices or on any computer (win, mac, *nix ...), without any modifications.","title":"Introduction"},{"location":"#guy","text":"Guy is a way to make a simple GUI for your python script, using html/js/css technologies (a lit bit like electron ). It borrows the idea from python-eel , but provide a lot more things. The main idea, is to reuse the installed chrome app on the host. So your script (or your freezed app) stays at the minimal footprint. But your user needs to have Chrome (or chromium) on its computer, to run your script/app. If you want to release a standalone/freezed app, with all included (your script + a chrome container). You can include special mode with cefpython3 . But the footprint will be around 60mo (like an electron app). But you can ;-) There are 3 modes to release your app : app : your user will need to have a chrome instance. The GUI will be handled by a chrome instance, runned in \"app mode\". (on android/ios, the GUI will be handled by webViewClient/kivy) cef : (stands for cefpython3): All is embedded, it's the embedded cef instance which will handle your GUI. server : it will act as an http server, and any browsers can handle your GUI. So, there can be multiple clients ! Like you understand, your GUI should be built with HTML/JS/CSS. Under the hood, guy provides a simple mechanisms (with websockets) to interact with the python technologies. Your GUI can be native HTML/JS or any modern js frameworks : vuejs, angular, etc ... The app mode can be runned on an Android device, using kivy/buildozer toolchain (for building an apk). Understand that the same app can be runned on any android devices or on any computer (win, mac, *nix ...), without any modifications.","title":"Guy"},{"location":"anatomy/","text":"Anatomy : how it works A guy's app can be seen as a single application. It could be true for app & cef mode. Under the hood : it's basically 2 things: Server Side : An http & socket server Client Side : A javascript lib which make the glue with the server. For app & cef mode : guy run the two in a windowed app. (there is one server & one client) For server mode : guy run the server, and a classical browser can be a client, when connected. (there is one server & many clients) In all cases : the http server serve the client as a html component. And the client communicate with the server with a websocket.","title":"Anatomy"},{"location":"anatomy/#anatomy-how-it-works","text":"A guy's app can be seen as a single application. It could be true for app & cef mode. Under the hood : it's basically 2 things: Server Side : An http & socket server Client Side : A javascript lib which make the glue with the server. For app & cef mode : guy run the two in a windowed app. (there is one server & one client) For server mode : guy run the server, and a classical browser can be a client, when connected. (there is one server & many clients) In all cases : the http server serve the client as a html component. And the client communicate with the server with a websocket.","title":"Anatomy : how it works"},{"location":"client/","text":"Client side : guy.js Not like the good old wuy ; javascript's apis are in two objetcs : guy : to handle the core of guy. self : to handle the declared methods in the guy's class, on server side Guy's apis guy.init( function() { ... } ) Will run the function when everything is started. It's a good place to start your logic. guy.on( event, function(arg1, arg2, ...) { ... } ) To listen to an event ... It returns a method to unsubscribe the listenner. guy.emit( event, arg1, arg2, ...) To emit an event to all connected clients. It's a non-sense in app or cef mode : because there is only one client. It only got sense in server mode. guy.emitMe( event, arg1, arg2, ...) To emit an event to the current client (me only;-)). guy.fetch( url, init ) Same as window.fetch , but it's the server which will do the request, to avoid CORS issues. guy.exit() Exit the app. guy.cfg A place to get/set vars, which will be stored on server side, in a config.json file. Self's apis It's all the apis which have been defined in the class instance. If you have a class like thant, on py side: class Simple ( Guy ): \"\"\"<button onclick=\"self.test()\">test</button>\"\"\" def test ( self ): print ( \"hello world\" ) You wil have a self.test() method in client side ! self.exit() Exit the current instance, if it's the main instance : it quits the app. self.parent A reference to the parent guy window, if embbeded window (WILL DETAIL SOON) ...","title":"Client side"},{"location":"client/#client-side-guyjs","text":"Not like the good old wuy ; javascript's apis are in two objetcs : guy : to handle the core of guy. self : to handle the declared methods in the guy's class, on server side","title":"Client side : guy.js"},{"location":"client/#guys-apis","text":"","title":"Guy's apis"},{"location":"client/#guyinit-function","text":"Will run the function when everything is started. It's a good place to start your logic.","title":"guy.init( function() { ... } )"},{"location":"client/#guyon-event-functionarg1-arg2","text":"To listen to an event ... It returns a method to unsubscribe the listenner.","title":"guy.on( event, function(arg1, arg2, ...) { ... } )"},{"location":"client/#guyemit-event-arg1-arg2","text":"To emit an event to all connected clients. It's a non-sense in app or cef mode : because there is only one client. It only got sense in server mode.","title":"guy.emit( event, arg1, arg2, ...)"},{"location":"client/#guyemitme-event-arg1-arg2","text":"To emit an event to the current client (me only;-)).","title":"guy.emitMe( event, arg1, arg2, ...)"},{"location":"client/#guyfetch-url-init","text":"Same as window.fetch , but it's the server which will do the request, to avoid CORS issues.","title":"guy.fetch( url, init )"},{"location":"client/#guyexit","text":"Exit the app.","title":"guy.exit()"},{"location":"client/#guycfg","text":"A place to get/set vars, which will be stored on server side, in a config.json file.","title":"guy.cfg"},{"location":"client/#selfs-apis","text":"It's all the apis which have been defined in the class instance. If you have a class like thant, on py side: class Simple ( Guy ): \"\"\"<button onclick=\"self.test()\">test</button>\"\"\" def test ( self ): print ( \"hello world\" ) You wil have a self.test() method in client side !","title":"Self's apis"},{"location":"client/#selfexit","text":"Exit the current instance, if it's the main instance : it quits the app.","title":"self.exit()"},{"location":"client/#selfparent","text":"A reference to the parent guy window, if embbeded window (WILL DETAIL SOON) ...","title":"self.parent"},{"location":"demo/","text":"Demo Only server's modes are available as demo : Here is a demo ( sources ), of a simple guy's app (server mode). Here is a demo ( sources ), of a guy's app serving a vuejs/sfc UI. If you want to try app/cef mode, just look the test*.py files here","title":"Demo"},{"location":"demo/#demo","text":"Only server's modes are available as demo : Here is a demo ( sources ), of a simple guy's app (server mode). Here is a demo ( sources ), of a guy's app serving a vuejs/sfc UI. If you want to try app/cef mode, just look the test*.py files here","title":"Demo"},{"location":"howto_build_apk_android/","text":"How to build an APK for Android You will need to install kivy and buildozer ! This How-to assume that you use a linux platform ;-) Known Limitations If you plan to use vbuild (to compile vue sfc components in html), to generate html. You can't use PyComponents . And you will need vbuild >= 0.8.1. (the module pscript can't be embedded in an apk) BTW, Some python modules can't be embedded in an APK : use pure python modules ! When you use html in docstring in a guy class. You will need to prefix your docstring like this __doc__=\"\"\"html\"\"\" . Because buildozer remove real docstrings from py files. Don't try to embed a GuyApp which are runned by app.runCef() or app.serve() ... only app.run() will work ;-) Install the tools sudo apt install python3-kivy python3 -m pip install --upgrade buildozer Note : you should install the kivy version which belongs to your platform For buildozer : you can pip it ! Create your first Guy's app Create an empty folder, and from it, run : buildozer init Note: it will create ... TODO TODO TODO (mainly from https://linuxfr.org/news/minipy-un-serveur-python-dans-son-android , french doc! ) Authorize \"Clear Text Traffic\" in your APK You will need to authorize your app to access the embedded python http server, which serve on localhost \"http\" only. To do that, you must enable \"Clear Text Traffic\" in your \"AndroidManifest.xml\". Using buildozer, you can change the template which will be used to generate the original. Add android:usesCleartextTraffic=\"true\" in tag <application> in AndroidManifest.tmpl.xml TODO TODO TODO Test on your smartphone Connect your smartphone with an usb cable to your computer, and run: $ buildozer android debug deploy run Your app should start on the phone ;-) Deploy in android's playstore You will need to sign your apk, before uploading it. You will need OpenJDK tools ! To release your apk: $ buildozer android release It will produce an apk file ... TODO TODO TODO","title":"Produce an APK/android"},{"location":"howto_build_apk_android/#how-to-build-an-apk-for-android","text":"You will need to install kivy and buildozer ! This How-to assume that you use a linux platform ;-)","title":"How to build an APK for Android"},{"location":"howto_build_apk_android/#known-limitations","text":"If you plan to use vbuild (to compile vue sfc components in html), to generate html. You can't use PyComponents . And you will need vbuild >= 0.8.1. (the module pscript can't be embedded in an apk) BTW, Some python modules can't be embedded in an APK : use pure python modules ! When you use html in docstring in a guy class. You will need to prefix your docstring like this __doc__=\"\"\"html\"\"\" . Because buildozer remove real docstrings from py files. Don't try to embed a GuyApp which are runned by app.runCef() or app.serve() ... only app.run() will work ;-)","title":"Known Limitations"},{"location":"howto_build_apk_android/#install-the-tools","text":"sudo apt install python3-kivy python3 -m pip install --upgrade buildozer Note : you should install the kivy version which belongs to your platform For buildozer : you can pip it !","title":"Install the tools"},{"location":"howto_build_apk_android/#create-your-first-guys-app","text":"Create an empty folder, and from it, run : buildozer init Note: it will create ... TODO TODO TODO (mainly from https://linuxfr.org/news/minipy-un-serveur-python-dans-son-android , french doc! )","title":"Create your first Guy's app"},{"location":"howto_build_apk_android/#authorize-clear-text-traffic-in-your-apk","text":"You will need to authorize your app to access the embedded python http server, which serve on localhost \"http\" only. To do that, you must enable \"Clear Text Traffic\" in your \"AndroidManifest.xml\". Using buildozer, you can change the template which will be used to generate the original. Add android:usesCleartextTraffic=\"true\" in tag <application> in AndroidManifest.tmpl.xml TODO TODO TODO","title":"Authorize \"Clear Text Traffic\" in your APK"},{"location":"howto_build_apk_android/#test-on-your-smartphone","text":"Connect your smartphone with an usb cable to your computer, and run: $ buildozer android debug deploy run Your app should start on the phone ;-)","title":"Test on your smartphone"},{"location":"howto_build_apk_android/#deploy-in-androids-playstore","text":"You will need to sign your apk, before uploading it. You will need OpenJDK tools ! To release your apk: $ buildozer android release It will produce an apk file ... TODO TODO TODO","title":"Deploy in android's playstore"},{"location":"howto_build_exe_windows/","text":"How to build an exe for Windows It can be very useful to distribute and exe on Microsoft Windows platforms (btw, you can freeze an executable on all platforms) You will need pyinstaller ! A \"light\" one, with the need of chrome on the host Who doesn't have chrome on its computer ?! If there is a chrome on the host. It's the best option : the exe will reuse the installed chrome in \"app mode\". The exe will be lighter (6mo min) It's the best option for app.run() or app.serve() modes in your main py file. pyinstaller.exe YourGuyApp.py --noupx --onefile --noconsole --exclude-module cefpython3 --add-data=\"static;static\" Notes: noupx : because, with upx it gives me errors ;-) onefile : to embed all needed runtime files. noconsole : like you want ... exclude-module cefpython3 : So you will need to have chrome on the host machine to be able to run the exe. add-data=\"static;static\" : to embed yours static file for rendering (css, images ...) A full one ; all included If you target an unknow windows computer, perhaps you should embed a chrome in the exe. It's possible with cefpython3 module. Install cefpython python3 -m pip install cefpython3 And change your app.run() into app.runCef() in your main py file. pyinstaller.exe YourGuyApp.py --noupx --onefile --noconsole --add-data=\"static;static\" Notes: your exe will be bigger (60mo min) noupx : because, with upx it gives me errors ;-) onefile : to embed all needed runtime files. noconsole : like you want ... add-data=\"static;static\" : to embed yours static file for rendering (css, images ...)","title":"Freeze exe/windows"},{"location":"howto_build_exe_windows/#how-to-build-an-exe-for-windows","text":"It can be very useful to distribute and exe on Microsoft Windows platforms (btw, you can freeze an executable on all platforms) You will need pyinstaller !","title":"How to build an exe for Windows"},{"location":"howto_build_exe_windows/#a-light-one-with-the-need-of-chrome-on-the-host","text":"Who doesn't have chrome on its computer ?! If there is a chrome on the host. It's the best option : the exe will reuse the installed chrome in \"app mode\". The exe will be lighter (6mo min) It's the best option for app.run() or app.serve() modes in your main py file. pyinstaller.exe YourGuyApp.py --noupx --onefile --noconsole --exclude-module cefpython3 --add-data=\"static;static\" Notes: noupx : because, with upx it gives me errors ;-) onefile : to embed all needed runtime files. noconsole : like you want ... exclude-module cefpython3 : So you will need to have chrome on the host machine to be able to run the exe. add-data=\"static;static\" : to embed yours static file for rendering (css, images ...)","title":"A \"light\" one, with the need of chrome on the host"},{"location":"howto_build_exe_windows/#a-full-one-all-included","text":"If you target an unknow windows computer, perhaps you should embed a chrome in the exe. It's possible with cefpython3 module. Install cefpython python3 -m pip install cefpython3 And change your app.run() into app.runCef() in your main py file. pyinstaller.exe YourGuyApp.py --noupx --onefile --noconsole --add-data=\"static;static\" Notes: your exe will be bigger (60mo min) noupx : because, with upx it gives me errors ;-) onefile : to embed all needed runtime files. noconsole : like you want ... add-data=\"static;static\" : to embed yours static file for rendering (css, images ...)","title":"A full one ; all included"},{"location":"howto_migrate_from_wuy_to_guy/","text":"How to migrate from wuy wuy is the ancestor of guy . Replace all wuy keyword in your py and html/js files, by guy Replace wuy.Window / wuy.Server by guy.Guy .get() & .set() configs are replaced by self.cfg (py side) and guy.cfg (js side) At launch, get the instance, and apply one of theses methods: instance.run() : for classical \"app mode\" instance.runCef() : for app mode in cefpython3 instance.serve() : for classical \"server mode\" Rename your web folder to static folder, if needed. From wuy: AppWindow () to guy: app = AppWindow () app . run () Info if socket close : client will reconnect ! (it will not close the app, like wuy did)","title":"From wuy to guy"},{"location":"howto_migrate_from_wuy_to_guy/#how-to-migrate-from-wuy","text":"wuy is the ancestor of guy . Replace all wuy keyword in your py and html/js files, by guy Replace wuy.Window / wuy.Server by guy.Guy .get() & .set() configs are replaced by self.cfg (py side) and guy.cfg (js side) At launch, get the instance, and apply one of theses methods: instance.run() : for classical \"app mode\" instance.runCef() : for app mode in cefpython3 instance.serve() : for classical \"server mode\" Rename your web folder to static folder, if needed. From wuy: AppWindow () to guy: app = AppWindow () app . run () Info if socket close : client will reconnect ! (it will not close the app, like wuy did)","title":"How to migrate from wuy"},{"location":"multiple/","text":"Multiple instances Not like the good old wuy . With guy you can use multiple guy's instance ! You can declare many Guy's class, and use them in a same app : it's easier to make bigger app ; you can leverage your logic/ui in multiple component. You can use theses others guy's class, in 2 manners ... TODO TODO TODO Embedded Window It's the ability to return a guy's class as response ... TODO TODO TODO See testPrompt.py Navigate to another window Just navigate to another window. TODO TODO TODO See testRedirect.py Info All windows share the same socket ! But each instance (on server side) is unique to a client.","title":"Multiple Instance"},{"location":"multiple/#multiple-instances","text":"Not like the good old wuy . With guy you can use multiple guy's instance ! You can declare many Guy's class, and use them in a same app : it's easier to make bigger app ; you can leverage your logic/ui in multiple component. You can use theses others guy's class, in 2 manners ... TODO TODO TODO","title":"Multiple instances"},{"location":"multiple/#embedded-window","text":"It's the ability to return a guy's class as response ... TODO TODO TODO See testPrompt.py","title":"Embedded Window"},{"location":"multiple/#navigate-to-another-window","text":"Just navigate to another window. TODO TODO TODO See testRedirect.py Info All windows share the same socket ! But each instance (on server side) is unique to a client.","title":"Navigate to another window"},{"location":"run/","text":"Run your app Admit you've got an app: from guy import Guy class YourApp ( Guy ): ... if __name__ == \"__main__\" : app = YourApp () app . run () #<- this is how to run it ;-) app mode Use app.run() Classical mode, on desktop : it uses the installed chrome browser in app mode. (it's the way to run on android too) cef mode Use app.runCef() Special mode for desktop : when you want to provide a standalone app, with all included. You will need cefpython3 ! server mode Use app.serve() Server mode, for servers. Optionnal parameters: port: (number) listening port, default: 8000. open: (bool) open default browser to the client, default: True","title":"Run guy's app"},{"location":"run/#run-your-app","text":"Admit you've got an app: from guy import Guy class YourApp ( Guy ): ... if __name__ == \"__main__\" : app = YourApp () app . run () #<- this is how to run it ;-)","title":"Run your app"},{"location":"run/#app-mode","text":"Use app.run() Classical mode, on desktop : it uses the installed chrome browser in app mode. (it's the way to run on android too)","title":"app mode"},{"location":"run/#cef-mode","text":"Use app.runCef() Special mode for desktop : when you want to provide a standalone app, with all included. You will need cefpython3 !","title":"cef mode"},{"location":"run/#server-mode","text":"Use app.serve() Server mode, for servers. Optionnal parameters: port: (number) listening port, default: 8000. open: (bool) open default browser to the client, default: True","title":"server mode"},{"location":"server/","text":"Server Side : python guy Basically, you subclass the guy class like this: #!/usr/bin/python3 -u from guy import Guy class Simple ( Guy ): size = ( 400 , 400 ) __doc__ = \"\"\"<button onclick=\"self.test()\">test</button>\"\"\" def test ( self ): print ( \"hello world\" ) And all declared methods will be available on client side . Here there will be a self.test() method in client side. Rendering Rendering with docstring It's the simplest thing : just declare your gui/html in the docstring of your class. class Simple ( Guy ): __doc__ = \"\"\"<button onclick=\"self.test()\">test</button>\"\"\" It's a fast way to release a simple component. But it's not adapted for larger app ;-) Info here is the __doc__ declaration. Which is needed if you want to release a component like that on android (because buildozer seems to remove them, if not prefixed) Rendering with an html file If you want to separate the UI from the code. You can put your html in a file named as the class name, in a static folder. It's the preferable way to go, for larger app. Info In this case : you should provide a tag <script src=\"guy.js\"></script> in your html. Rendering override Sometimes, you need to make more things, and you can do it, by overriding the _render(self, path) method of your class. For bigger app : I use vbuild to render vuejs/sfc components. (see starter-guy-vuejs , and demo ) class App ( Guy ): def _render ( self , path ): # override default with open ( \"app/APP.html\" ) as fid : buf = fid . read () r = vbuild . render ( \"app/*.vue\" ) buf = buf . replace ( \"<!-- TPLS -->\" , r . html ) buf = buf . replace ( \"/* CSS */\" , r . style ) buf = buf . replace ( \"/* JS */\" , r . script ) return buf Info In this case : you should provide a tag <script src=\"guy.js\"></script> in your response. Guy Class init(self) Override this method to do thing, when a client is connected. self.emit( event, arg1, arg2 ... ) Call this method to emit an event to all connected clients. It's a non-sense in app or cef mode : because there is only one client. It only got sense in server mode. self.emitMe( event, arg1, arg2 ... ) Call this method to emit an event to the connected client. self.cfg A place to get/set vars, which will be stored on server side, in a config.json file. size With this class attribut you can specify the size of your window. This is a non-sense, in server mode. Because, it's the client which determine the size of its tab. class Simple ( Guy ): size = ( 400 , 400 ) \"\"\"<button onclick=\"self.test()\">test</button>\"\"\" class Simple ( guy . Guy ): size = guy . FULLSCREEN \"\"\"<button onclick=\"self.test()\">test</button>\"\"\" Static content guy will serve everything that is contained in a static folder, as static content. Hook http Guy provides an http decorator to handle specific http requests. It can be useful for a lot of things. from guy import http @http ( \"/item/(\\d+)\" ) def getItem ( web , number ): web . write ( \"item %s \" % number ) web is a Tornado's TequestHandler","title":"Server side"},{"location":"server/#server-side-python-guy","text":"Basically, you subclass the guy class like this: #!/usr/bin/python3 -u from guy import Guy class Simple ( Guy ): size = ( 400 , 400 ) __doc__ = \"\"\"<button onclick=\"self.test()\">test</button>\"\"\" def test ( self ): print ( \"hello world\" ) And all declared methods will be available on client side . Here there will be a self.test() method in client side.","title":"Server Side : python guy"},{"location":"server/#rendering","text":"","title":"Rendering"},{"location":"server/#rendering-with-docstring","text":"It's the simplest thing : just declare your gui/html in the docstring of your class. class Simple ( Guy ): __doc__ = \"\"\"<button onclick=\"self.test()\">test</button>\"\"\" It's a fast way to release a simple component. But it's not adapted for larger app ;-) Info here is the __doc__ declaration. Which is needed if you want to release a component like that on android (because buildozer seems to remove them, if not prefixed)","title":"Rendering with docstring"},{"location":"server/#rendering-with-an-html-file","text":"If you want to separate the UI from the code. You can put your html in a file named as the class name, in a static folder. It's the preferable way to go, for larger app. Info In this case : you should provide a tag <script src=\"guy.js\"></script> in your html.","title":"Rendering with an html file"},{"location":"server/#rendering-override","text":"Sometimes, you need to make more things, and you can do it, by overriding the _render(self, path) method of your class. For bigger app : I use vbuild to render vuejs/sfc components. (see starter-guy-vuejs , and demo ) class App ( Guy ): def _render ( self , path ): # override default with open ( \"app/APP.html\" ) as fid : buf = fid . read () r = vbuild . render ( \"app/*.vue\" ) buf = buf . replace ( \"<!-- TPLS -->\" , r . html ) buf = buf . replace ( \"/* CSS */\" , r . style ) buf = buf . replace ( \"/* JS */\" , r . script ) return buf Info In this case : you should provide a tag <script src=\"guy.js\"></script> in your response.","title":"Rendering override"},{"location":"server/#guy-class","text":"","title":"Guy Class"},{"location":"server/#initself","text":"Override this method to do thing, when a client is connected.","title":"init(self)"},{"location":"server/#selfemit-event-arg1-arg2","text":"Call this method to emit an event to all connected clients. It's a non-sense in app or cef mode : because there is only one client. It only got sense in server mode.","title":"self.emit( event, arg1, arg2 ... )"},{"location":"server/#selfemitme-event-arg1-arg2","text":"Call this method to emit an event to the connected client.","title":"self.emitMe( event, arg1, arg2 ... )"},{"location":"server/#selfcfg","text":"A place to get/set vars, which will be stored on server side, in a config.json file.","title":"self.cfg"},{"location":"server/#size","text":"With this class attribut you can specify the size of your window. This is a non-sense, in server mode. Because, it's the client which determine the size of its tab. class Simple ( Guy ): size = ( 400 , 400 ) \"\"\"<button onclick=\"self.test()\">test</button>\"\"\" class Simple ( guy . Guy ): size = guy . FULLSCREEN \"\"\"<button onclick=\"self.test()\">test</button>\"\"\"","title":"size"},{"location":"server/#static-content","text":"guy will serve everything that is contained in a static folder, as static content.","title":"Static content"},{"location":"server/#hook-http","text":"Guy provides an http decorator to handle specific http requests. It can be useful for a lot of things. from guy import http @http ( \"/item/(\\d+)\" ) def getItem ( web , number ): web . write ( \"item %s \" % number ) web is a Tornado's TequestHandler","title":"Hook http"},{"location":"simplest/","text":"The simplest guy app could look like this #!/usr/bin/python3 -u from guy import Guy class Simple ( Guy ): \"\"\"<button onclick=\"self.test()\">test</button>\"\"\" def test ( self ): print ( \"hello world\" ) if __name__ == \"__main__\" : app = Simple () app . run () Will run an app mode . And can be runned on any OS (android, windows, *nix, mac/iOS, ...) Info If you want to act as a cef instance, replace app.run() by app.runCef() If you want to act as a http server, replace app.run() by app.serve()","title":"Example"},{"location":"simplest/#the-simplest-guy-app-could-look-like-this","text":"#!/usr/bin/python3 -u from guy import Guy class Simple ( Guy ): \"\"\"<button onclick=\"self.test()\">test</button>\"\"\" def test ( self ): print ( \"hello world\" ) if __name__ == \"__main__\" : app = Simple () app . run () Will run an app mode . And can be runned on any OS (android, windows, *nix, mac/iOS, ...) Info If you want to act as a cef instance, replace app.run() by app.runCef() If you want to act as a http server, replace app.run() by app.serve()","title":"The simplest guy app could look like this"}]}